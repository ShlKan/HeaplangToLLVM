(** This file implements a key-value store (or called map) in heaplang based on Trie. There two operations
are defined `map_get` and `map_set`.
(1) `map_get` retrieves a the value bound to a key.
(2) `map_set` binds a value to a key.

The correctness of the implementation are proved based on refinement specification.
The abstract model we use Pmap in stdpp. The Pmap's definition is as follows.
[Pmap](https://gitlab.mpi-sws.org/iris/stdpp/-/blob/master/stdpp/pmap.v?ref_type=heads)

```Coq
 Inductive Pmap_ne (A: Type) : Type :=
 | Node001: tree’ A → tree’ A (∗ only a right subtree ∗)
 | Node010: A → tree’ A (∗ only a middle value ∗)
 | Node011: A → tree’ A → tree’ A (∗ only middle and right ∗)
 | Node100: tree’ A → tree’ A (∗ only a left subtree ∗)
 | Node101: tree’ A → tree’ A → tree’ A (∗ left, right, no middle ∗)
 | Node110: tree’ A → A → tree’ A (∗ only left and middle ∗)
 | Node111: tree’ A → A → tree’ A → tree’ A. (∗ left, middle, right ∗)

 Inductive Pmap (A: Type) : Type :=
 | Empty : tree A
 | Nodes: tree’ A → tree A.
```

In heaplang, the map is implemented as binary tree. Each node in the tree is a triple:
`(left, mid, right)`, where
  (1) `left`: is the left branch of the node.
  (2) `right`: is the right branch of the node.
  (3) `mid`: is the data contained in the current node.

  If `left = #()` then the left branch is nullptr.
  If `right = #()` then the right branch is nullptr.
  If `mid = NONE` then there is no data in this node.

The correctness proof of `map_get` and `map_set` is carried out by establishing the
Pmap's tree to this binary tree.
*)


From iris.heap_lang Require Import lang proofmode notation spawn par.
From stdpp Require Import pmap.


(** For test only. *)
(* From iris.unstable.heap_lang Require Import interpreter. *)

Local Open Scope positive_scope.

Section map_heaplang.
Context `{!heapGS Σ}.


(** `get_left`.
  Get the left branch of the binary tree.
 *)
Definition get_left : val :=
  λ: "v", Fst "v".

(** `get_right`.
  Get the right branch of the binary tree.
 *)
Definition get_right : val :=
  λ: "v", Snd (Snd "v").

(** `get_mid`.
  Get the data of the current node.
 *)
Definition get_mid : val :=
  λ: "v", Fst (Snd "v").

(** For test only. *)
(* Compute (exec 10 get_mid (#1, #2, #3)).  *)


(** `map_set`.
  Set the key's value to `fv v' v`, where v' is the current value bound to key.

The value to be bound to a key is generated by a function `fv`. `fv` makes it
flexible for different application scenarios.

(1) CmpXhg: compare and exchange operation can be implemented by `fv`.
    For example, we update the value of `k` to `v` only when the old value
    bound to `k` is `vo`. The function `fv` can be defined as:
    `λ v' v, if (v' = vo) then v else v'`.

(2) The value bound to a key can be pointer (loc) in the heaplang. If `fv`
    can be defined to modify some parts of the value pointed by the pointer,
    then `map_set` play the role of updating data to a key.

(3) Normal case, just bound a new value to a key, `fv` can be defined as
    `λ _, v, v`.

The function "f" applies to "key" and get two values: ("rest", "residue").
  1. "residue" defines which branch to proceed.
  2. "rest" defines the value to be used in the next step.

Given an example. "f" can be [ λ v. (v / 2, v % 2) ].
The function "f" should have some properties to be specified later.

"base" is the value means that the current node should be set with ("fdata" data).
"left" is the value means that the current node should proceed to the left branch.
"right" is the value means that current node should proceed to the right branch.

The function `f` allows us not to bound the type of key to `positive` values as in Pmap.
 *)

Definition map_set : val :=
  rec: "map_set" "m" "f" "base" "left" "right" "key" "v" "fv" :=
      let: "m'" :=
        if: "m" = #() then
          ref (#(), (NONEV, (* x *) #()))
        else
          "m" in
      if: "key" = "base" then
        "m'" <- (get_left (! "m'"),
                  (SOME ("fv" (get_mid (! "m'")) "v"), get_right (! "m'")));;
        "m'"
      else
        let: "res" := "f" "key" in
        let: "rest" := (Fst "res") in
        let: "residue" := (Snd "res") in
        if: "residue" = "left" then
          let: "left_branch" :=
            "map_set" (get_left (! "m'"))
              "f" "base" "left" "right" "rest" "v" "fv" in
          "m'" <- ("left_branch", (get_mid (! "m'"), get_right (! "m'"))) ;;
          "m'"
        else
          let: "right_branch" :=
            "map_set" (get_right (! "m'"))
              "f" "base" "left" "right" "rest" "v" "fv" in
          "m'" <- (get_left (! "m'"), (get_mid (! "m'"), "right_branch")) ;;
          "m'".


(* For test only. *)
(* Definition f : val :=
  λ: "v", Pair ("v" `quot` #2) ("v" `rem` #2). *)


(* For test only. *)
(* Definition fdata: val :=
  λ: "ov" "v", match: "ov" with
                 NONE => "v"
               | SOME "ov'" => if: "ov'"= #1 then "ov'" else "v" end. *)


(* Test 1: Create a map with a unique key. *)
(* Compute (exec 100 (map_set #() f #0 #0 #1 #0 #5 fdata)). *)


(** map_get.
  Get the value bound to "key".
  The function "f" applies to "key" and get two values: ("rest", "residue").
  1. "residue" defines which branch to proceed.
  2. "rest" defines the value to be used in the next step.

  Given an example. "f" can be [ λ v. (v / 2, v % 2) ].

  "base" is the value means that the current node's value should be returned.
  "left" is the value means that map_get function should proceed to the left branch.
  "right" is the value means that map_get function should proceed to the right branch.
 *)
Definition map_get : val :=
  rec: "map_get" "m" "f" "base" "left" "right" "key" :=
    if: "m" = #() then NONE (* An empty map, just return NONE. *)
    else
      if: "key" = "base" then
        get_mid (! "m")
      else
        let: "res" := "f" "key" in
        let: "rest" := (Fst "res") in
        let: "residue" := (Snd "res") in
        if: "residue" = "left" then
          "map_get" (get_left (! "m")) "f" "base" "left" "right" "rest"
        else
          "map_get" (get_right (! "m")) "f" "base" "left" "right" "rest".


(* Test 2: with map_get we can test the value corresponding to the key.
   The key #0 is bound to #5. map_get #0 should return #5. *)
(*
Compute (exec 1000 (map_get
                      (map_set #() f #0 #0 #1 #0 #5 fdata)
                      f #0 #0 #1 #0
        )). *)


(** For test only.
 This map contains 3 key-value pairs:
 (1) 0 → 5
 (2) 6 → 9
 (3) 100 → 11 *)
(*
Example test_map : expr :=
  let: "m1" := map_set #() f #0 #0 #1 #0 #5 fdata in
  let: "m2" := map_set "m1" f #0 #0 #1 #6 #1 fdata in
  let: "m3" := map_set "m2" f #0 #0 #1 #100 #11 fdata in
  "m3".
*)

(* Test 3: Check the key #0, it should be 5. *)
(* Compute (exec 1000 (map_get test_map f #0 #0 #1 #0)).  *)
  

(* Test 4: Check the key #6, it should be 9. *)
(* Compute (exec 1000 (map_get test_map f #0 #0 #1 #6)). *)

(* Test 3: Check the key #100, it should be 11. *)
(* Compute (exec 1000 (map_get test_map f #0 #0 #1 #100)). *)

(* Test 5: Check the key #115, it should be NONE. *)
(* Compute (exec 1000 (map_get test_map f #0 #0 #1 #115)). *)

(* Here we update the value on the key #6. *)
(* Example test_map' : expr := map_set test_map f #0 #0 #1 #6 #7 fdata. *)

(* Retrive the value on the key #6, it should be still #1 instead of #7.
 The reason is the function [ fdata ] does not update value of #1. *)
(* Compute (exec 1000 (map_get test_map f #0 #0 #1 #6)).  *)


(** Specification and Correctness Proof of map_get and map_set. *)

(** Predicate: isPmap_ne.
 We need to establish isomorphism between pmap and the heaplang implementation.
 This can also be viewed as refinement relation.

`isPmap_ne l pm_ne` denotes that the binary tree pointed by `l` is a refinement
of `pm_ne`.  *)


Fixpoint isPmap_ne (l : val) (pm_ne : Pmap_ne val) : iProp Σ :=
  match pm_ne with
  | PNode001 rb => ∃ lr (l':loc), ⌜ l = #l' ⌝ ∗ l' ↦ (#(), (NONEV, lr)) ∗ isPmap_ne lr rb
  | PNode010 m => ∃ (l':loc), ⌜ l = #l' ⌝ ∗ l' ↦ (#(), (SOMEV m, #()))
  | PNode011 m rb => ∃ (l':loc) lr, ⌜ l = #l' ⌝ ∗ l' ↦ (#(), (SOMEV m, lr)) ∗
                                       isPmap_ne lr rb
  | PNode100 lb => ∃ ll (l':loc), ⌜ l = #l' ⌝ ∗ l' ↦ (ll, (NONEV, #())) ∗
                                       isPmap_ne ll lb
  | PNode101 lb rb => ∃ ll lr (l':loc), ⌜ l = #l' ⌝ ∗ l' ↦ (ll, (NONEV, lr)) ∗
                                            isPmap_ne ll lb ∗ isPmap_ne lr rb
  | PNode110 lb m => ∃ ll (l': loc), ⌜ l = #l' ⌝ ∗ l' ↦ (ll, (SOMEV m, #())) ∗
                                              isPmap_ne ll lb
  | PNode111 lb m rb => ∃ ll lr (l' : loc), ⌜ l = #l' ⌝ ∗ l' ↦ (ll, (SOMEV m, lr)) ∗
                                                 isPmap_ne ll lb ∗ isPmap_ne lr rb 
end.


(** The refinement relation predicate between binary tree and Pmap. *)
Definition isPmap l (pm : Pmap val) : iProp Σ :=
  match pm with
  | PEmpty => ⌜ l = #() ⌝
  | PNodes ne => isPmap_ne l ne 
  end.


(** The correlation between positive and a general key.
 Because Pmap uses positive as keys. But we don't want to
 bind our implementaton to postive type. We use generic type together
 with a function (fc). But the replations between postive and
 the general keys should be established.

 `key` is a general key and `key` is a positive key.
 Their corresponding relation are defined by
 (1) the mapping function `fp`.
 (2) `fc_exec` and
 (3) `positive_bij`.

 The corresponding relation are as follows:
 (1) `fp key = key'`
 (2) if `key` is `p~1`, then `fc key = (v1, v2)` and `v2 = right ∧ fp v1 = p`
 (3) if `key` is `p~0`, then `fc key = (v1, v2)` and `v2 = left ∧ fp v1 = p`
 *)

Definition fc_exec
  (p10: bool)
  (key lv rv: val)
  (key':positive)
  (fp:val → positive)
  (fc:val)
  Pred
  :=
  {{{  ⌜ fp key = if p10 then key'~1 else key'~0 ⌝  }}}
    fc key
  {{{v, RET v; ∃ (v1 v2: val),
          ⌜ v = (PairV v1 v2) ⌝ ∗ ⌜ p10 = true → v2 = rv ⌝ ∗
          ⌜ p10 = false → v2 = lv ⌝ ∗ ⌜ Pred v1 lv rv key' fp fc ⌝
}}}.


Fixpoint positive_bij (key lv rv: val) (key':positive) fp fc :=
  match key' with
    1%positive => fp key = key'
  | p~1 => fp key = key' ∧ fc_exec true key lv rv p fp fc positive_bij
  | p~0 => fp key = key' ∧ fc_exec false key lv rv p fp fc positive_bij
  end.

(** Convert Coq's option value to Heaplang option value. *)
Definition op_to_val v :=
  match v with
  | None => NONEV
  | Some v' => SOMEV v'
  end. 
Print expr.


(** `map_get correct specification`
 Precondition:
 (1) `l` and `pm` have refinement relation.
 (2) `key` and `key'` have the corresponding relation of positive_bij.
 (3) `fp key = key'` 

 Postcondition:
 (1) The return value of `Pmap` and `heaplang`'s map should be the same.
 (2) The map pointed by `l` should not be modified.
 *)
Lemma map_get_correct
  (l : val)
  (pm : Pmap val)
  fc
  (base:val)
  (lv:val)
  (rv:val)
  (key:val)
  key'
  (fp:val -> positive)
  (fp_inj: ∀ (v1 v2:val), (v1 ≠ v2 → fp v1 ≠ fp v2)%V)
  (Hbase_unboxed: val_is_unboxed base)
  (Hlv_unboxed: val_is_unboxed lv)
  (Hrv_unboxed: val_is_unboxed rv)
  (HfpBase: fp base = 1%positive)
  (Hneqrlv: rv ≠ lv):
  {{{ isPmap l pm ∗ ⌜ positive_bij key lv rv key' fp fc ⌝ ∗ ⌜ fp key = key' ⌝}}}
    map_get l fc base lv rv key
  {{{ v, RET v; ⌜ v = op_to_val (lookup key' pm) ⌝ ∗ isPmap l pm }}}.
Proof.
  destruct pm as [|ne Hne].
  - iIntros (ϕ) "[%HisMap [%Hkey %HkeyEq]] Hϕ".
    rewrite HisMap.  
    wp_rec.
    wp_pures.
    iModIntro.
    iApply "Hϕ".
    iSplit.
    + iPureIntro.
      simpl.
      reflexivity.
    + done.
  - revert l key key'.
    induction ne.
    (* Proof of the branch 001. *) 
    + iIntros (l key key' ϕ) "[(%lr & %l' & %Hll'eq & Hl' & Hne) [%Hf1 %Hf2]] Hϕ".
      fold isPmap_ne.
      rewrite Hll'eq.
      wp_rec.
      wp_pures.
      destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
      {
        wp_pure.
        rewrite /get_mid.
        wp_load.
        wp_pures.
        iModIntro.
        iApply "Hϕ". 
        iSplitR "Hne Hl'".
        - iPureIntro.
          rewrite Hkbeq in Hf2.
          rewrite HfpBase in Hf2.
          rewrite <- Hf2.
          done.
        - iExists lr, l'.
          fold isPmap_ne.
          iFrame.
          iPureIntro.
          done.
      }
      {
        wp_pures.
        destruct key' as [p1 | p0 |].
        - destruct Hf1 as [Hf11 Hf12].
          unfold fc_exec in Hf12.
          wp_apply Hf12.
          + done.
          + iIntros (v) "(%v1 & %v2 & %Hv & %Hv1 & %Hv2  & %Hpos')".
            rewrite Hv.
            wp_pures.
            assert (Hverveq: v2 = rv).
            {
              apply Hv1. done.
            }
            rewrite Hverveq.
            wp_pures.
            destruct (bool_decide_reflect(rv = lv)) as [Hrleq|Hrlneq].
            done.
            {
              wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              iApply (IHne with "[Hne]").
              iFrame.
              iSplit.
              - iPureIntro.
                apply Hpos'.
              - iPureIntro.
                destruct p1.
                + destruct Hpos' as [Hv1p1eq _].
                  done.
                + destruct Hpos' as [Hv1p1eq _]; done.
                + destruct Hpos' as [Hv1p1eq]; done.
              - iModIntro.
                iIntros (v0) "[%H1 H2]".
                iApply "Hϕ".
                iFrame.
                iSplit.
                + iPureIntro.
                  done.
                + done.
            }
          - destruct Hf1 as [Hf11 Hf12].
            unfold fc_exec in Hf12.
            wp_apply Hf12.
            + done.
            + iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv.
              wp_pures.
              assert (Hv2lv: v2 = lv).
              {apply Hv2l;done.}
              rewrite Hv2lv.
              destruct (bool_decide_reflect(lv = lv)) as [H1 | H2].
              {
                wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.
                wp_rec.
                wp_pures.
                iModIntro.
                iApply "Hϕ".
                iFrame.
                iSplit.
                iPureIntro.
                done.
                done.
              }
              done.
          - assert (Heqfp: fp key ≠ fp base).
            {
              apply fp_inj.
              done.
            }
            rewrite HfpBase in Heqfp.
            done.
      }
      + iIntros (l key key' ϕ) "[(%l' & %Hl & HisMap) [%Hpos %Fkey]] Hϕ".
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures.
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite Hkbeq in Fkey.
          rewrite HfpBase in Fkey.
          rewrite <- Fkey.
          done.
          done.          
        }
        {
          wp_pures.
          destruct key' as [p1 | p0 |].
          Print positive_bij.
          - destruct Hpos as [Hfp Hfcexec].
            wp_apply Hfcexec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            destruct (bool_decide_reflect (v2 = lv)) as [Hv2leq| Hv2lneq].
            + assert (Hv2rv: v2 = rv).
              apply Hv2r; done.
              rewrite Hv2leq in Hv2rv.
              done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_rec.
              wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              done.
          - destruct Hpos as [Hfp Hfcexec].
            wp_apply Hfcexec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lvEq: v2 = lv).
            apply Hv2l; done.
            rewrite Hv2lvEq.
            destruct (bool_decide_reflect (lv = lv)) as [Hlveq | Hlvneq].
            + wp_pures.
              wp_load.
              unfold get_left.
              wp_pures.
              wp_rec; wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              done.
            + done.
          - destruct Hpos.
            assert (HfpkbNeq: fp base ≠ fp key).
            apply fp_inj; done.
            done.
        }
      + iIntros (l key key' ϕ) "[(%l' & %lr & %Hl & Hl' & HisPmap) [%HPos %Hkey]] Hϕ". 
        fold isPmap_ne.
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures.
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite <- Hkbeq in HfpBase.
          rewrite Hkey in HfpBase.
          rewrite HfpBase.
          done.
          done.
        }
        {
          wp_pures.
          destruct key'.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %HPos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2rveq: v2 = rv). apply Hv2r; done.
            rewrite Hv2rveq.
            destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlnEq].
            + wp_pures.
              wp_load.
              unfold get_left.
              wp_pures.
              wp_rec; wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              iApply (IHne with "[HisPmap]").
              iFrame.
              iSplit.
              done.
              destruct key'.
              Print positive_bij.
              destruct HPos as [Hfpkey' _].
              done.
              destruct HPos as [Hfpkey' _]; done.
              destruct HPos; done.
              iNext.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lveq: v2 = lv). apply Hv2l; done.
            rewrite Hv2lveq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load; unfold get_left; wp_pures.
              wp_rec; wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              done; done.
            + done.
          - destruct HPos.
            assert (HfpkeyNeq: fp key ≠ fp base). apply fp_inj; done.
            done.
        }
      + iIntros (l key key' ϕ) "[(%ll & %l' & %Hl & Hl' & HisPmap) [%Hpos %Hkey]] Hϕ".
        fold isPmap_ne.
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures.
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite <- Hkbeq in HfpBase.
          rewrite Hkey in HfpBase.
          rewrite HfpBase.
          done.
          done.
        }
        {
          wp_pures.
          destruct key'.
          - destruct Hpos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %HPos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2rveq: v2 = rv). apply Hv2r; done.
            rewrite Hv2rveq.
            destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlnEq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_rec; wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
          - destruct Hpos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lveq: v2 = lv). apply Hv2l; done.
            rewrite Hv2lveq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load; unfold get_left; wp_pures.
              wp_apply (IHne with "[HisPmap]").
              iFrame.
              iSplit.
              done.
              iPureIntro. 
              destruct key'.
              destruct Hpos as [H1 _].
              done.
              destruct Hpos as [H1 _]; done.
              destruct Hpos; done.
              iIntros (v0) "[Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              done.
            + done.
          - destruct Hpos.
            assert (HfpkeyNeq: fp key ≠ fp base). apply fp_inj; done.
            done.
        } 
      + iIntros (l key key' ϕ) "[(%ll & %lr & %l' & %Hl & Hl' & HisPmap1 & HisPmap2) [%HPos %Hkey]] Hϕ".
        fold isPmap_ne.
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures.
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite <- Hkbeq in HfpBase.
          rewrite Hkey in HfpBase.
          rewrite HfpBase.
          done.
          done.
        }
        {
          wp_pures.
          destruct key'.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %HPos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2rveq: v2 = rv). apply Hv2r; done.
            rewrite Hv2rveq.
            destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlnEq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              iApply (IHne2 with "[HisPmap2]").
              iFrame.
              iSplit.
              done.
              iPureIntro.
              destruct key'.
              Print positive_bij.
              destruct HPos as [Hfpkey' _].
              done.
              destruct HPos as [Hfpkey' _]; done.
              destruct HPos; done.
              iNext.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lveq: v2 = lv). apply Hv2l; done.
            rewrite Hv2lveq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load; unfold get_left; wp_pures.
              wp_apply (IHne1 with "[HisPmap1]").
              iFrame.
              iSplit.
              done.
              destruct key'.
              Print positive_bij.
              destruct Hpos as [Hfpkey' _].
              done.
              destruct Hpos as [Hfpkey' _]; done.
              destruct Hpos; done.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
            + done.
          - destruct HPos.
            assert (HfpkeyNeq: fp key ≠ fp base). apply fp_inj; done.
            done.
        } 
      + (* The Proof of the Branch PNode110. *)
        iIntros (l key key' ϕ) "[(%ll & %l' & %Hl & Hl' & HisPmap) [%HPos %Hkey]] Hϕ".
        fold isPmap_ne.
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures.
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite <- Hkbeq in HfpBase.
          rewrite Hkey in HfpBase.
          rewrite HfpBase.
          done.
          done.
        }
        {
          wp_pures.
          destruct key'.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %HPos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2rveq: v2 = rv). apply Hv2r; done.
            rewrite Hv2rveq.
            destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlnEq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_rec.
              wp_pures.
              iModIntro.
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lveq: v2 = lv). apply Hv2l; done.
            rewrite Hv2lveq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load; unfold get_left; wp_pures.
              wp_apply (IHne with "[HisPmap]").
              iFrame.
              iSplit.
              done.
              destruct key'.
              Print positive_bij.
              destruct Hpos as [Hfpkey' _].
              done.
              destruct Hpos as [Hfpkey' _]; done.
              destruct Hpos; done.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
            + done.
          - destruct HPos.
            assert (HfpkeyNeq: fp key ≠ fp base). apply fp_inj; done.
            done.
        }
      (* The Proof of the Branch PNode111. *)
      + iIntros (l key key' ϕ) "[(%ll & %lr & %l' & %Hl & Hl' & HisPmap1 & HisPmap2) [%HPos %Hkey]] Hϕ".
        fold isPmap_ne.
        rewrite Hl.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [Hkbeq | Hkbneq].
        {
          wp_pures. 
          wp_load.
          unfold get_mid.
          wp_pures.
          iModIntro.
          iApply "Hϕ".
          iFrame.
          iSplit.
          iPureIntro.
          rewrite <- Hkbeq in HfpBase.
          rewrite Hkey in HfpBase.
          rewrite HfpBase.
          done.
          done.
        }
        {
          wp_pures.
          destruct key'.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %HPos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2rveq: v2 = rv). apply Hv2r; done.
            rewrite Hv2rveq.
            destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlnEq].
            + done.
            + wp_pures.
              wp_load. 
              unfold get_right.
              wp_pures.
              iApply (IHne2 with "[HisPmap2]").
              iFrame.
              iSplit.
              done.
              iPureIntro.
              destruct key'.
              Print positive_bij.
              destruct HPos as [Hfpkey' _].
              done.
              destruct HPos as [Hfpkey' _]; done.
              destruct HPos; done.
              iNext.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
          - destruct HPos as [Hfpkey fc_exec].
            wp_apply fc_exec.
            done.
            iIntros (v) "(%v1 & %v2 & %Hv & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv.
            wp_pures.
            assert (Hv2lveq: v2 = lv). apply Hv2l; done.
            rewrite Hv2lveq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load; unfold get_left; wp_pures.
              wp_apply (IHne1 with "[HisPmap1]").
              iFrame.
              iSplit.
              done.
              destruct key'.
              Print positive_bij.
              destruct Hpos as [Hfpkey' _].
              done.
              destruct Hpos as [Hfpkey' _]; done.
              destruct Hpos; done.
              iIntros (v0) "[%Hv0 HisPmap]".
              iApply "Hϕ".
              iFrame.
              iSplit.
              done.
              done.
            + done.
          - destruct HPos.
            assert (HfpkeyNeq: fp key ≠ fp base). apply fp_inj; done.
            done.
        } 
Qed.



(** The Correctness Specification and Proof of `map_set` *)

(** Helping definition. *)
Definition is_Pnodes {A:Type} (mx : Pmap A) := ∃ x, mx = PNodes x.

(** Helping lemma. *)
Lemma is_Pnodes_alt {A} (mx : Pmap A) :
  is_Pnodes mx ↔ match mx with PNodes _ => True | PEmpty => False end.
Proof.
  unfold is_Pnodes.
  destruct mx.
  naive_solver.
  naive_solver.
Qed.

(** Helping lemma. *)
Lemma not_eq_Pnodes {A} (mx : Pmap A) : mx ≠ PEmpty ↔ is_Pnodes mx.
Proof.
  rewrite is_Pnodes_alt.
  destruct mx.
  naive_solver.
  naive_solver.
  Qed.

(** Helping lemma. *)
Lemma NoPEmpty
  (pm: Pmap val)
  (key:positive)
  (f: option val → option val)
  (fNoneNot: ∀ x, f x ≠ None):
  partial_alter f key pm ≠ PEmpty.
Proof.
  assert (fNoneN: ∃ x, f None = Some x).
      {
        apply not_eq_None_Some.
        done.
      }
  destruct fNoneN as [x].
  induction pm as [| ne].
  - induction key as [p1 H1 | p0 H0 |].
    + unfold partial_alter.
      simpl.
      rewrite H.
      done.
    + unfold partial_alter.
      simpl.
      rewrite H.
      done.
    + unfold partial_alter.
      simpl.
      rewrite H.
      done.
  - revert ne.
    induction key as [p1 H1| p0 H0|].
    intro ne.
    unfold partial_alter.
    simpl.
    destruct ne.
    + 
      simpl.
      unfold partial_alter in H1.
      unfold Pmap_partial_alter in H1.
      unfold pmap.Pmap_partial_alter_aux in H1.
      assert (HH:pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
      done.
      assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p1 ne = PNodes n).
      {
        apply not_eq_Pnodes.
        done.
      }
      destruct is_Pmapne as [n is_Pmapne];
      rewrite is_Pmapne;
      done.
    + simpl.
      assert (f None ≠ None).
      {
        apply fNoneNot.
      }
      assert (H2:∃ vv, f None = Some vv).
      apply not_eq_None_Some; done.
      destruct H2 as [vv Hvv].
      rewrite Hvv.
      done.
    + simpl.
      unfold partial_alter in H1.
      unfold Pmap_partial_alter in H1.
      unfold pmap.Pmap_partial_alter_aux in H1.
      assert (HH:pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
      done.
      assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p1 ne = PNodes n).
      {
        apply not_eq_Pnodes.
        done.
      }
      destruct is_Pmapne as [n is_Pmapne].
      rewrite is_Pmapne.
      done.
    + simpl.
      assert (f None ≠ None).
      {
        apply fNoneNot.
      }
      assert (H2:∃ vv, f None = Some vv).
      apply not_eq_None_Some; done.
      destruct H2 as [vv Hvv].
      rewrite Hvv.
      done.
    + simpl.
      unfold partial_alter in H1.
      unfold Pmap_partial_alter in H1.
      unfold pmap.Pmap_partial_alter_aux in H1.
      assert (HH:pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
      done.
      assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p1 ne2 = PNodes n).
      {
        apply not_eq_Pnodes.
        done.
      }
      destruct is_Pmapne as [n is_Pmapne].
      rewrite is_Pmapne.
      done.
    + simpl.
      unfold partial_alter in H1.
      unfold Pmap_partial_alter in H1.
      unfold pmap.Pmap_partial_alter_aux in H1.
      assert (HH:pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
      done.
      assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p1 ne = PNodes n).
      {
        apply not_eq_Pnodes.
        done.
      }
      destruct is_Pmapne as [n is_Pmapne].
      assert (f None ≠ None).
      {
        apply fNoneNot.
      }
      assert (H2:∃ vv, f None = Some vv).
      apply not_eq_None_Some; done.
      destruct H2 as [vv Hvv].
      rewrite Hvv.
      done.
    + simpl.
      assert (f None ≠ None).
      {
        apply fNoneNot.
      }
      assert (H2:∃ vv, f None = Some vv).
      apply not_eq_None_Some; done.
      destruct H2 as [vv Hvv].
      unfold partial_alter in H1.
      unfold Pmap_partial_alter in H1.
      unfold pmap.Pmap_partial_alter_aux in H1.
      assert (HH:pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
      done.
      assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p1 ne2 = PNodes n).
      {
        apply not_eq_Pnodes.
        done.
      }
      destruct is_Pmapne as [n is_Pmapne].
      rewrite is_Pmapne.
      done.
    + destruct ne.
      {
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.
      }
      {
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.
      }
      {
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.
      }
      { simpl.
        unfold partial_alter in H0.
        unfold Pmap_partial_alter in H0.
        unfold pmap.Pmap_partial_alter_aux in H0.
        assert (HH:pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
        done.
        assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p0 ne = PNodes n).
        {
          apply not_eq_Pnodes.
          done.
        }
        destruct is_Pmapne as [n is_Pmapne].
        rewrite is_Pmapne;
        done.
      }
      {
        simpl.
        unfold partial_alter in H0.
        unfold Pmap_partial_alter in H0.
        unfold pmap.Pmap_partial_alter_aux in H0.
        assert (HH:pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
        done.
        assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p0 ne1 = PNodes n).
        {
          apply not_eq_Pnodes.
          done.
        }
        destruct is_Pmapne as [n is_Pmapne].
        rewrite is_Pmapne.
        done.
      } {
        simpl.
        unfold partial_alter in H0.
        unfold Pmap_partial_alter in H0.
        unfold pmap.Pmap_partial_alter_aux in H0.
        assert (HH:pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
        done.
        assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p0 ne = PNodes n).
        {
          apply not_eq_Pnodes.
          done.
        }
        destruct is_Pmapne as [n is_Pmapne].
        rewrite is_Pmapne.
        done.      
      }
      {
        simpl.
        unfold partial_alter in H0.
        unfold Pmap_partial_alter in H0.
        unfold pmap.Pmap_partial_alter_aux in H0.
        assert (HH:pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
        done.
        assert (is_Pmapne: ∃ n, pmap.Pmap_ne_partial_alter f p0 ne1 = PNodes n).
        {
          apply not_eq_Pnodes.
          done.
        }
        destruct is_Pmapne as [n is_Pmapne].
        rewrite is_Pmapne.
        done.
      }
    + intro ne.
      destruct ne.
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f (Some v) ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f (Some v) = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f (Some v) ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f (Some v) = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f None ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f None = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f (Some v) ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f (Some v) = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
      {
        simpl.
        unfold partial_alter.
        simpl.
        assert (f (Some v) ≠ None).
        {
          apply fNoneNot.
        }
        assert (H2:∃ vv, f (Some v) = Some vv).
        apply not_eq_None_Some; done.
        destruct H2 as [vv Hvv].
        rewrite Hvv.
        done.      
      }
Qed.

(** fv function specification.
Pmap uses `f`: option A → option A to update value.
The heaplang implmentation use: `fv` : option val → option val to update value.
There must be corresponding relation between `f` and `fv` established.

`fv_constraint` establish this relation.

Note that, in the proof `map_set`, we will not allow `fv e = None`. We will
think `fv e = None` as node deleting and prove separately in the future if needed. *)
Definition to_opt (v: val) : option val :=
  match v with
  | NONEV => None
  | SOMEV e => Some e
  | v => Some v
  end.

Definition fv_constraint
  (fv:val)
  (v:val)
  (f: option val -> option val)
  (ov: val)
  :=
  {{{ True }}}
    fv ov v
  {{{ rv, RET rv; ⌜ Some rv = f (to_opt ov) ⌝ }}}.


      
(** `map_get` correct specification
 Precondition:
 (1) `l` and `pm` have refinement relation.
 (2) `key` and `key'` have the corresponding relation of positive_bij.
 (3) `fp key = key'`
 (4) `fv` and `f` has `fv_constraint` relation.

 Postcondition:
 (1) The return value `ll` of `map_set` should be a refinement
     of the Pmap `pm` after binding the new value to `key'`. *)      
Lemma map_set_correct
  (l : val)
  (pm : Pmap val)
  fc
  (base:val)
  (lv:val)
  (rv:val)
  (key:val)
  (v: val)
  (fv:val)
  (f: option val -> option val)
  (f_always: ∀ x, f x ≠ None)
  key'
  (fp:val -> positive)
  (fp_inj: ∀ (v1 v2:val), (v1 ≠ v2 → fp v1 ≠ fp v2)%V)
  (Hbase_unboxed: val_is_unboxed base)
  (Hlv_unboxed: val_is_unboxed lv)
  (Hrv_unboxed: val_is_unboxed rv)
  (HfpBase: fp base = 1%positive)
  (Hneqrlv: rv ≠ lv)
  (Hfv_constraint: ∀ k, fv_constraint fv v f k):
  {{{ isPmap l pm ∗ ⌜ positive_bij key lv rv key' fp fc ⌝ ∗ ⌜ fp key = key' ⌝}}}
    map_set l fc base lv rv key v fv
  {{{ ll, RET ll; isPmap ll (partial_alter f key' pm) }}}.
Proof.
  assert (HextVV: ∀ p, ∃ vv, f p = Some vv). {
    intros p.
    assert (HfpNotNone: f p ≠ None).
    apply f_always.
    apply not_eq_None_Some.
    done.
  }
  assert (HExpPmap: ∀ p:Pmap val, p ≠ PEmpty → ∃ vv, p = PNodes vv). {
    intros p HNEmpty.
    destruct p as [ | v1].
    done.
    exists v1.
    done.
  }
  
  iLöb as "IH" forall (key key' pm l).
  destruct pm as [| ne].
  - iIntros (ϕ) "[%HisMap [%Hkey %HkeyEq]] Hϕ".
    wp_rec.
    rewrite HisMap.
    wp_pures.
    wp_alloc l' as "Hl'".
    wp_pures.
    destruct (bool_decide_reflect (key = base)) as [HkbEq | HkbNeq].
    + wp_pures.
      unfold get_left.
      unfold get_mid.
      unfold get_right.
      wp_load.
      wp_pures.
      wp_load.
      wp_pures.
      wp_apply (Hfv_constraint (NONEV)).
      done.
      {
        iIntros (rv0) "%H1".
        assert (HrvfNoneEq: Some rv0 = f None).
        {
          apply H1.
        }
        wp_pures.
        wp_load.
        wp_pures.
        wp_store.
        iApply "Hϕ".
        iModIntro.
        rewrite HkbEq in HkeyEq.
        rewrite HfpBase in HkeyEq.
        rewrite <- HkeyEq.
        simpl.
        unfold partial_alter.
        unfold Pmap_partial_alter.
        unfold pmap.Pmap_partial_alter_aux.
        rewrite <- HrvfNoneEq.
        simpl.
        iExists l'.
        iFrame.
        iPureIntro.
        done.
      }
    + wp_pures.
      destruct key' as [p1 | p0 | ].
      destruct Hkey as [fpkey  fp_exec].
      wp_apply fp_exec.
      done.
      {
        iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
        rewrite Hv0.
        wp_pures.
        assert (Hv2rv: v2 = rv). apply Hv2r; done.
        rewrite Hv2rv.
        destruct (bool_decide_reflect (rv = lv)) as [HrlEq | HrlNeq].
        done.
        - wp_pures.
          wp_load.
          unfold get_right.
          wp_pures.
          wp_apply "IH".
          + iSplit.
            iAssert (isPmap #() PEmpty) as "H".
            done.
            iApply "H".
            iSplit.
            done.
            destruct p1.
            destruct Hpos as [H1 _]. done.
            destruct Hpos as [H1 _]. done.
            destruct Hpos. done.
          + iIntros (ll) "H1".
            wp_pures.
            unfold get_left.
            unfold get_mid.
            wp_load.
            wp_pures.
            wp_load.
            wp_pures.
            wp_store.
            iModIntro.
            iApply "Hϕ". 
            unfold isPmap.
            unfold partial_alter.
            simpl.
            assert (HfNotNone: f None ≠ None). done.
            assert (HfSome: ∃ vv, f None = Some vv).
            {
              apply not_eq_None_Some.
              done.
            }
            destruct HfSome as [vv].
            rewrite H.
            unfold isPmap.
            simpl.
            iExists ll, l'.
            iFrame.
            iPureIntro.
            done.
      }
      {
        destruct Hkey as [HkeyVal  f_exec].
        wp_apply f_exec.
        done.
        iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos )".
        rewrite Hv0.
        wp_pures.
        assert (Hv2lvEq: v2 = lv). apply Hv2l; done.
        rewrite Hv2lvEq.
        destruct (bool_decide_reflect (lv = lv)) as [HllEq | HllNeq].
        wp_pures.
        wp_load.
        unfold get_left.
        wp_pures.
        wp_apply "IH".
        - iSplit.
          iAssert (isPmap #() PEmpty) as "H".
          done.
          iApply "H".
          iSplit.
          done.
          destruct p0.
          destruct Hpos as [H1 _].
          done.
          destruct Hpos as [H1 _].
          done.
          destruct Hpos.
          done.
        - iIntros (ll) "HisMap".
          wp_pures.
          wp_load.
          unfold get_right.
          wp_pures.
          unfold get_mid.
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          unfold isPmap.
          unfold partial_alter.
          simpl.
          assert (HfNoneNeq: f None ≠ None). done.
          assert (HfNoneSome: ∃ vv, f None = Some vv).
          {
            apply not_eq_None_Some.
            done.
          }
          destruct HfNoneSome as (vv & fvv).
          rewrite fvv.
          simpl.
          iExists ll, l'. 
          iFrame.
          done.
        - done.          
      }     
      {
        destruct Hkey.
        assert (Hneqf: fp key ≠ fp base).
        {
          apply fp_inj; done.
        }
        done.
      }
  - destruct ne.
    (* The Proof of the Branch PNode 001. *)
      + iIntros (ϕ) "[(%lr & %l' & %Hll'eq & Hl' & Hne) [%Hf1 %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkebEq | HkebNeq].
        {
          wp_pures.
          wp_load.
          unfold get_left.
          unfold get_right.
          unfold get_mid.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint NONEV).
          iPureIntro.
          done.
          iIntros (rv0) "%H1".
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          unfold isPmap.
          unfold partial_alter.
          rewrite HkebEq in Hf2.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          simpl.
          assert(HfNoneN: f None ≠ None).
          done.
          assert(HfSome: ∃ vv, f None = Some vv).
          {
            apply not_eq_None_Some.
            done.
          }
          destruct HfSome as [vv].
          rewrite H.
          simpl.
          iExists l', lr.
          iFrame.
          iSplit.
          done.
          assert (Hrv0fNone: Some rv0 = f None).
          {
            apply H1.
          }
          rewrite H in Hrv0fNone.
          assert(Hrv0vv: rv0 = vv).
          injection Hrv0fNone.
          intro Hrv0vveq.
          done.
          rewrite Hrv0vv.
          done.
        }
        {
          wp_pures.
          destruct key' as [p1 | p0 |].
          destruct Hf1 as [HlvEq fc_exec].
          wp_apply fc_exec.
          - done.
          - iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
            rewrite Hv0.
            wp_pures.
            assert (Hv2rv: v2 = rv). apply Hv2r; done.
            rewrite Hv2rv.
            destruct (bool_decide_reflect (rv = lv)) as [HrlvEq | HrlvNEq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_apply ("IH" with "[Hne]").
              iSplit.
              iAssert (isPmap lr (PNodes ne)) with "[Hne]" as "H".
              done.
              iApply "H".
              iSplit.
              done.
              iPureIntro.
              destruct p1 as [p1 | p0 |].
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos as [Hp0 _].
              done.
              destruct Hpos.
              done.
              {
                iIntros (ll) "HisPmap".
                wp_pures.
                unfold get_left.
                unfold get_mid.
                wp_load.
                wp_pures.
                wp_load.
                wp_pures.
                wp_store.
                iModIntro.
                iApply "Hϕ".
                simpl.
                unfold partial_alter.
                simpl.         
                destruct (pmap.Pmap_ne_partial_alter f p1 ne) eqn:E.
                2:{
                  simpl.
                  iExists ll, l'.
                  iSplit.
                  done.
                  iSplitL "Hl'".
                  done.
                  done.
                }
                {
                  Check NoPEmpty.
                  assert (HnonEmpty:
                           partial_alter f p1 (PNodes ne) ≠ PEmpty →
                           pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
                  {
                    intro H1.
                    unfold partial_alter in H1.
                    unfold Pmap_partial_alter in H1.
                    unfold pmap.Pmap_partial_alter_aux in H1. 
                    done.
                  }
                  assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
                  {
                    apply HnonEmpty.
                    apply NoPEmpty.
                    done.
                  }
                  done.
                }
                }
          - destruct Hf1 as [Hfp0 fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hlv2Eq: v2 = lv).
              {
                apply Hv2l.
                done.
              }
              rewrite Hlv2Eq.
              destruct (bool_decide_reflect (lv = lv)) as [HllEq | HllNeq].
              {
                wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.          
                wp_apply "IH".
                - iSplit.
                  + iAssert (isPmap #() (PEmpty)) as "H".
                    done.
                    iApply "H".
                  + iSplit.
                    done.
                    iPureIntro.
                    destruct p0 as [p1 | p0 |].
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _ ].
                    done.
                - iIntros (ll) "HisPmap".
                  wp_pures.
                  unfold get_mid.
                  unfold get_right.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  unfold isPmap.
                  simpl.
                  unfold partial_alter.
                  simpl.
                  assert (HfNoneNeq: f None ≠ None).
                  {
                    apply f_always.
                  }
                  assert (Hvv: ∃ vv:val, f None = Some vv).
                  {
                    apply not_eq_None_Some.
                    done.
                  }
                  destruct Hvv as [vv Hvv].
                  rewrite Hvv.
                  simpl.
                  iExists ll, lr, l'.
                  iFrame.
                  done.
              }
              done.
          - (* This case is impossible, as we already have key ≠ base. *)
            assert (HfpkebaseNeq: fp key ≠ fp base).
            {
              apply fp_inj.
              done.
            }
            assert (HfpkebaseEq: fp key = fp base).
            rewrite <- Hf2 in HfpBase.
            done.
            done.
        }
      (* The Proof of the Branch PNode 010. *)
      + Print isPmap_ne.
        iIntros (ϕ) "[(%l' & %Hll'eq & Hl') [%Hf1 %Hf2]] Hϕ".
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkbEq | HkbNeq].
        {
          wp_pures.
          unfold get_left.
          unfold get_mid.
          unfold get_right.
          wp_load.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint (SOMEV v0)).
          done.
          iIntros (rv0) "%Hv0Eq".
          assert (Hrv0Eq: Some rv0 = f (Some v0)).
          apply Hv0Eq. 
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          rewrite <- HkbEq in HfpBase.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          unfold partial_alter.
          simpl.
          assert (Hfv0NeqNone: f (Some v0) ≠ None).
          apply f_always.
          assert (Hvv: ∃ vv:val, f (Some v0) = Some vv).
          apply not_eq_None_Some.
          apply Hfv0NeqNone.
          destruct Hvv as [vv Hvv].
          rewrite Hvv.
          simpl.
          iExists l'.
          rewrite Hvv in Hrv0Eq.
          assert (Hrv0vv: rv0 = vv).
          injection Hrv0Eq.
          intro H'.
          done.
          rewrite <- Hrv0vv.
          iFrame.
          done.
        }
        {
          wp_pures.
          destruct key' as [ p1 | p0 | ].
          - destruct Hf1 as [Hf11 Hf12].
            wp_apply Hf12.
            done.
            iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
            rewrite Hv1.
            wp_pures.
            assert (Hv3rvEq: v3 = rv).
            apply Hv3r; done.
            rewrite Hv3rvEq.
            destruct (bool_decide_reflect(rv = lv)) as [HrlEq | HrlNeq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_apply "IH".
              iSplit.
              iAssert (isPmap #() PEmpty) as "HisPmapEmpty".
              done.
              iApply "HisPmapEmpty".
              iSplit.
              done.
              iPureIntro.
              destruct p1 as [p1 | p0 |].
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos.
              done.
              iIntros (ll) "HisPmap".
              wp_pures.
              unfold get_left.
              wp_load.
              unfold get_mid.
              wp_pures.
              wp_load.
              wp_pures.
              wp_store.
              iModIntro.
              iApply "Hϕ".
              assert (fNoneNotNone: f None ≠ None).
              {
                apply f_always.
              }
              assert (Hvv: ∃ vv: val, f None = Some vv).
              {
                apply not_eq_None_Some.
                done.
              }
              destruct Hvv as [vv Hvv].
              unfold isPmap.
              unfold partial_alter.
              simpl.
              rewrite Hvv.
              simpl.
              iExists l', ll.
              iSplit.
              done.
              iSplitL "Hl'".
              done.
              done.
            - destruct Hf1 as [Hfkey Hf_exec].
              wp_apply Hf_exec.
              done.
              iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
              rewrite Hv1.
              wp_pures.
              assert (Hv3Eq: v3 = lv). apply Hv3l; done.
              rewrite Hv3Eq.
              destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
              + wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.
                wp_apply "IH".
                iSplit.
                iAssert (isPmap #() PEmpty) as "HisPmapEmpty".
                done.
                iApply "HisPmapEmpty".
                iSplit.
                done.
                iPureIntro.
                destruct p0 as [p1 | p0 |].
                destruct Hpos as [H1 _].
                done.
                destruct Hpos as [H1 _].
                done.
                destruct Hpos; done.
                iIntros (ll) "HisPMap".
                wp_pures.
                unfold get_mid.
                unfold get_right.
                wp_load.
                wp_pures.
                wp_load. 
                wp_pures.
                wp_store.
                iModIntro.
                iApply "Hϕ".
                unfold isPmap.
                unfold partial_alter.
                simpl.
                destruct (HextVV None) as [vv Hvv].
                rewrite Hvv.
                simpl.
                iExists ll, l'.
                iFrame.
                done.
              + done.
            - destruct Hf1.
              assert (HfpkbNeq: fp key ≠ fp base). apply fp_inj; done.
              done.  
        } 
      + (* The Proof of PNode 011 *)
        Print isPmap_ne.
        iIntros (ϕ) "[(%l' & %lr & %Hll'eq & Hl' & Hne) [%Hpos %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkbEq | HkbNeq].
        {
          wp_pures.
          unfold get_left.
          unfold get_mid.
          unfold get_right.
          wp_load.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint (SOMEV v0)).
          done.
          iIntros (rv0) "%Hv0Eq".
          assert (Hrv0Eq: Some rv0 = f (Some v0)).
          apply Hv0Eq. 
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          rewrite <- HkbEq in HfpBase.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          unfold partial_alter.
          simpl.
          assert (Hfv0NeqNone: f (Some v0) ≠ None).
          apply f_always.
          assert (Hvv: ∃ vv:val, f (Some v0) = Some vv).
          apply not_eq_None_Some.
          apply Hfv0NeqNone.
          destruct Hvv as [vv Hvv].
          rewrite Hvv.
          simpl.
          iExists l',  lr.
          rewrite Hvv in Hrv0Eq.
          assert (Hrv0vv: rv0 = vv).
          injection Hrv0Eq.
          intro H'.
          done.
          rewrite <- Hrv0vv.
          iFrame.
          done.
        }
        {
          wp_pures.
          destruct key' as [ p1 | p0 | ].
          - destruct Hpos as [Hf11 Hf12].
            wp_apply Hf12.
            done.
            iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
            rewrite Hv1.
            wp_pures.
            assert (Hv3rvEq: v3 = rv).
            apply Hv3r; done.
            rewrite Hv3rvEq.
            destruct (bool_decide_reflect(rv = lv)) as [HrlEq | HrlNeq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_apply ("IH" with "[Hne]").
              iSplit.
              iAssert (isPmap lr (PNodes ne)) with "[Hne]" as "HisPmapEmpty".
              done.
              iApply "HisPmapEmpty".
              iSplit.
              done.
              iPureIntro.
              destruct p1 as [p1 | p0 |].
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos.
              done.
              iIntros (ll) "HisPmap".
              wp_pures.
              unfold get_left.
              wp_load.
              unfold get_mid.
              wp_pures.
              wp_load.
              wp_pures.
              wp_store.
              iModIntro.
              iApply "Hϕ".
              unfold partial_alter.
              simpl.
              destruct (pmap.Pmap_ne_partial_alter f p1 ne) as [ | vne] eqn:E.
              2:{
                simpl.
                iExists l', ll.
                iFrame.
                done.
              } {
                assert (HnonEmpty: partial_alter f p1 (PNodes ne) ≠ PEmpty →
                           pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
                  {
                    intro H1.
                    unfold partial_alter in H1.
                    unfold Pmap_partial_alter in H1.
                    unfold pmap.Pmap_partial_alter_aux in H1. 
                    done.
                  }
                  assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p1 ne ≠ PEmpty).
                  {
                    apply HnonEmpty.
                    apply NoPEmpty.
                    done.
                  }
                  done.
              }
          - destruct Hpos as [Hf1 Hf_exec].
            wp_apply Hf_exec.
            done.
            iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
            rewrite Hv1.
            wp_pures.
            assert (Hv3Eq: v3 = lv). apply Hv3l; done.
            rewrite Hv3Eq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load.
              unfold get_left.
              wp_pures.
              wp_apply "IH".
              iSplit.
              iAssert (isPmap #() PEmpty) as "HisPmapEmpty".
              done.
              iApply "HisPmapEmpty".
              iSplit.
              done.
              iPureIntro.
              destruct p0 as [p1 | p0 |].
              destruct Hpos as [H1 _].
              done.
              destruct Hpos as [H1 _].
              done.
              destruct Hpos; done.
              iIntros (ll) "HisPMap".
              wp_pures.
              unfold get_mid.
              unfold get_right.
              wp_load.
              wp_pures.
              wp_load. 
              wp_pures.
              wp_store.
              iModIntro.
              iApply "Hϕ".
              unfold isPmap.
              unfold partial_alter.
              simpl.
              destruct (HextVV None) as [vv Hvv].
              rewrite Hvv.
              simpl.
              iExists ll, lr, l'.
              iFrame.
              done.
            + done.
          - destruct Hpos.
            assert (HfpkbNeq: fp key ≠ fp base). apply fp_inj; done.
            done.  
        }
     (* The Proof of the Branch PNode 100. *)
      + iIntros (ϕ) "[(%ll & %l' & %Hll'eq & Hl' & Hne) [%Hf1 %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkebEq | HkebNeq].
        {
          wp_pures.
          wp_load.
          unfold get_left.
          unfold get_right.
          unfold get_mid.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint NONEV).
          done.
          iIntros (rv0) "%H1".
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          unfold isPmap.
          unfold partial_alter.
          rewrite HkebEq in Hf2.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          simpl.
          assert(HfNoneN: f None ≠ None).
          done.
          assert(HfSome: ∃ vv, f None = Some vv).
          {
            apply not_eq_None_Some.
            done.
          }
          destruct HfSome as [vv].
          rewrite H.
          simpl.
          iExists ll, l'.
          iFrame.
          iSplit.
          done.
          assert (Hrv0fNone: Some rv0 = f None).
          {
            apply H1.
          }
          rewrite H in Hrv0fNone.
          assert(Hrv0vv: rv0 = vv).
          injection Hrv0fNone.
          intro Hrv0vveq.
          done.
          rewrite Hrv0vv.
          done.
        }
        {
          wp_pures.
          destruct key' as [p1 | p0 |].
          - destruct Hf1 as [Hfp0 fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hlv2Eq: v2 = rv).
              {
                apply Hv2r.
                done.
              }
              rewrite Hlv2Eq.
              destruct (bool_decide_reflect (rv = lv)) as [HllEq | HllNeq].
              {
                done.
              }
              {
                wp_pures.
                wp_load.
                unfold get_right.
                wp_pures.          
                wp_apply "IH".
                - iSplit.
                  + iAssert (isPmap #() (PEmpty)) as "H".
                    done.
                    iApply "H".
                  + iSplit.
                    done.
                    iPureIntro.
                    destruct p1 as [p1 | p0 |].
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _ ].
                    done.
                - iIntros (lr) "HisPmap".
                  wp_pures.
                  unfold get_mid.
                  unfold get_right.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  unfold get_left.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  unfold isPmap.
                  simpl.
                  unfold partial_alter.
                  simpl.
                  assert (HfNoneNeq: f None ≠ None).
                  {
                    apply f_always.
                  }
                  assert (Hvv: ∃ vv:val, f None = Some vv).
                  {
                    apply not_eq_None_Some.
                    done.
                  }
                  destruct Hvv as [vv Hvv].
                  rewrite Hvv.
                  simpl.
                  iExists ll, lr, l'.
                  iFrame.
                  done.
              }
          - destruct Hf1 as [HlvEq fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hv2lv: v2 = lv). apply Hv2l; done.
              rewrite Hv2lv. 
              destruct (bool_decide_reflect (lv = lv)) as [HrlvEq | HrlvNEq].
              {
                wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.
                wp_apply ("IH" with "[Hne]").
                iSplit.
                iAssert (isPmap ll (PNodes ne)) with "[Hne]" as "H".
                done.
                iApply "H".
                iSplit.
                done.
                iPureIntro.
                destruct p0 as [p1 | p0 |].
                destruct Hpos as [Hp1 _].
                done.
                destruct Hpos as [Hp0 _].
                done.
                destruct Hpos.
                done.
                {
                  iIntros (ll0) "HisPmap".
                  wp_pures.
                  unfold get_right.
                  unfold get_mid.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  simpl.
                  unfold partial_alter.
                  simpl.         
                  destruct (pmap.Pmap_ne_partial_alter f p0 ne) eqn:E.
                  2:{
                    simpl.
                    iExists ll0, l'.
                    iSplit.
                    done.
                    iSplitL "Hl'".
                    done.
                    done.
                  }
                  {
                    Check NoPEmpty.
                    assert (HnonEmpty:
                             partial_alter f p0 (PNodes ne) ≠ PEmpty →
                             pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
                    {
                      intro H1.
                      unfold partial_alter in H1.
                      unfold Pmap_partial_alter in H1.
                      unfold pmap.Pmap_partial_alter_aux in H1. 
                      done.
                    }
                    assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
                    {
                      apply HnonEmpty.
                      apply NoPEmpty.
                      done.
                    }
                    done.
                  }
                }
              }
              done.
          - (* This case is impossible, as we already have key ≠ base. *)
            assert (HfpkebaseNeq: fp key ≠ fp base).
            {
              apply fp_inj.
              done.
            }
            assert (HfpkebaseEq: fp key = fp base).
            rewrite <- Hf2 in HfpBase.
            done.
            done.
        }
      + (* The proof of PNode101 *) 
        Print isPmap_ne.
        iIntros (ϕ) "[(%ll & %lr & %l' & %Hll'eq & Hl' & Hne1 & Hne2) [%Hf1 %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkebEq | HkebNeq].
        {
          wp_pures.
          wp_load.
          unfold get_left.
          unfold get_right.
          unfold get_mid.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint NONEV).
          done.
          iIntros (rv0) "%H1".
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          unfold isPmap.
          unfold partial_alter.
          rewrite HkebEq in Hf2.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          simpl.
          assert(HfNoneN: f None ≠ None).
          done.
          assert(HfSome: ∃ vv, f None = Some vv).
          {
            apply not_eq_None_Some.
            done.
          }
          destruct HfSome as [vv].
          rewrite H.
          simpl.
          iExists ll, lr, l'.
          iFrame.
          iSplit.
          done.
          assert (Hrv0fNone: Some rv0 = f None).
          {
            apply H1.
          }
          rewrite H in Hrv0fNone.
          assert(Hrv0vv: rv0 = vv).
          injection Hrv0fNone.
          intro Hrv0vveq.
          done.
          rewrite Hrv0vv.
          done.
        }
        { 
          wp_pures.
          destruct key' as [p1 | p0 |].
          - destruct Hf1 as [Hfp0 fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hlv2Eq: v2 = rv).
              {
                apply Hv2r.
                done.
              }
              rewrite Hlv2Eq.
              destruct (bool_decide_reflect (rv = lv)) as [HllEq | HllNeq].
              {
                done.
              }
              {
                wp_pures.
                wp_load.
                unfold get_right.
                wp_pures.          
                wp_apply ("IH" with "[Hne2]").
                - iSplit.
                  + iAssert (isPmap lr (PNodes ne2)) with "[Hne2]" as "H".
                    done.
                    iApply "H".
                  + iSplit.
                    done.
                    iPureIntro.
                    destruct p1 as [p1 | p0 |].
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _ ].
                    done.
                - iIntros (lr0) "HisPmap".
                  wp_pures.
                  unfold get_mid.
                  unfold get_right.
                  unfold get_left.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  unfold get_left.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  simpl.
                  unfold partial_alter.
                  simpl.      
                  destruct (pmap.Pmap_ne_partial_alter f p1 ne2) eqn:E.
                  2:{
                    simpl.
                    iExists ll, lr0, l'.
                    iSplit.
                    done.
                    iSplitL "Hl'".
                    done.
                    iFrame.
                  }
                  {
                    Check NoPEmpty.
                    assert (HnonEmpty:
                             partial_alter f p1 (PNodes ne2) ≠ PEmpty →
                             pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
                    {
                      intro H1.
                      unfold partial_alter in H1.
                      unfold Pmap_partial_alter in H1.
                      unfold pmap.Pmap_partial_alter_aux in H1. 
                      done.
                    }
                    assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
                    {
                      apply HnonEmpty.
                      apply NoPEmpty.
                      done.
                    }
                    done.
                  }
              }
          - destruct Hf1 as [HlvEq fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v0) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hv2lv: v2 = lv). apply Hv2l; done.
              rewrite Hv2lv. 
              destruct (bool_decide_reflect (lv = lv)) as [HrlvEq | HrlvNEq].
              {
                wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.
                wp_apply ("IH" with "[Hne1]").
                iSplit.
                iAssert (isPmap ll (PNodes ne1)) with "[Hne1]" as "H".
                done.
                iApply "H".
                iSplit.
                done.
                iPureIntro.
                destruct p0 as [p1 | p0 |].
                destruct Hpos as [Hp1 _].
                done.
                destruct Hpos as [Hp0 _].
                done.
                destruct Hpos.
                done.
                {
                  iIntros (ll0) "HisPmap".
                  wp_pures.
                  unfold get_right.
                  unfold get_mid.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  simpl.
                  unfold partial_alter.
                  simpl.      
                  destruct (pmap.Pmap_ne_partial_alter f p0 ne1) eqn:E.
                  2:{
                    simpl.
                    iExists ll0, lr, l'.
                    iSplit.
                    done.
                    iSplitL "Hl'".
                    done.
                    iFrame.
                  }
                  {
                    Check NoPEmpty.
                    assert (HnonEmpty:
                             partial_alter f p0 (PNodes ne1) ≠ PEmpty →
                             pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
                    {
                      intro H1.
                      unfold partial_alter in H1.
                      unfold Pmap_partial_alter in H1.
                      unfold pmap.Pmap_partial_alter_aux in H1. 
                      done.
                    }
                    assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
                    {
                      apply HnonEmpty.
                      apply NoPEmpty.
                      done.
                    }
                    done.
                  }
                }
              }
              {
                done.
              } 
          - (* This case is impossible, as we already have key ≠ base. *)
            assert (HfpkebaseNeq: fp key ≠ fp base).
            {
              apply fp_inj.
              done.
            }
            assert (HfpkebaseEq: fp key = fp base).
            rewrite <- Hf2 in HfpBase.
            done.
            done.
        }
      + (* The Proof of PNode110. *) 
        Print isPmap_ne.
        iIntros (ϕ) "[(%ll & %l' & %Hll'eq & Hl' & Hne) [%Hpos %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkbEq | HkbNeq].
        {
          wp_pures.
          unfold get_left.
          unfold get_mid.
          unfold get_right.
          wp_load.
          wp_pures.
          wp_load.
          wp_pures.
          wp_apply (Hfv_constraint (SOMEV v0)).
          done.
          iIntros (rv0) "%Hv0Eq".
          assert (Hrv0Eq: Some rv0 = f (Some v0)).
          apply Hv0Eq. 
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          rewrite <- HkbEq in HfpBase.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          unfold partial_alter.
          simpl.
          assert (Hfv0NeqNone: f (Some v0) ≠ None).
          apply f_always.
          assert (Hvv: ∃ vv:val, f (Some v0) = Some vv).
          apply not_eq_None_Some.
          apply Hfv0NeqNone.
          destruct Hvv as [vv Hvv].
          rewrite Hvv.
          simpl.
          iExists ll,  l'.
          rewrite Hvv in Hrv0Eq.
          assert (Hrv0vv: rv0 = vv).
          injection Hrv0Eq.
          intro H'.
          done.
          rewrite <- Hrv0vv.
          iFrame.
          done.
        }
        {
          wp_pures.
          destruct key' as [ p1 | p0 | ].
          - destruct Hpos as [Hf11 Hf12].
            wp_apply Hf12.
            done.
            iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
            rewrite Hv1.
            wp_pures.
            assert (Hv3rvEq: v3 = rv).
            apply Hv3r; done.
            rewrite Hv3rvEq.
            destruct (bool_decide_reflect(rv = lv)) as [HrlEq | HrlNeq].
            + done.
            + wp_pures.
              wp_load.
              unfold get_right.
              wp_pures.
              wp_apply ("IH").
              iSplit.
              iAssert (isPmap #() (PEmpty)) as "HisPmapEmpty".
              done.
              iApply "HisPmapEmpty".
              iSplit.
              done.
              iPureIntro.
              destruct p1 as [p1 | p0 |].
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos as [Hp1 _].
              done.
              destruct Hpos.
              done.
              iIntros (lr) "HisPmap".
              wp_pures.
              unfold get_left.
              wp_load.
              unfold get_mid.
              wp_pures.
              wp_load.
              wp_pures.
              wp_store.
              iModIntro.
              iApply "Hϕ".
              unfold isPmap.
              unfold partial_alter.
              simpl.
              destruct (HextVV None) as [vv Hvv].
              rewrite Hvv.
              simpl.
              iExists ll, lr, l'.
              iFrame.
              done.             
          - destruct Hpos as [Hf1 Hf_exec].
            wp_apply Hf_exec.
            done.
            iIntros (v1) "(%v2 & %v3 & %Hv1 & %Hv3r & %Hv3l & %Hpos)".
            rewrite Hv1.
            wp_pures.
            assert (Hv3Eq: v3 = lv). apply Hv3l; done.
            rewrite Hv3Eq.
            destruct (bool_decide_reflect (lv = lv)) as [HlvEq | HlvNeq].
            + wp_pures.
              wp_load.
              unfold get_left.
              wp_pures.
              wp_apply ("IH" with "[Hne]").
              iSplit.
              iAssert (isPmap ll (PNodes ne)) with "Hne" as "HisPmapEmpty".              
              iApply "HisPmapEmpty".
              iSplit.
              done.
              iPureIntro.
              destruct p0 as [p1 | p0 |].
              destruct Hpos as [H1 _].
              done.
              destruct Hpos as [H1 _].
              done.
              destruct Hpos; done.
              iIntros (ll0) "HisPMap".
              wp_pures.
              unfold get_mid.
              unfold get_right.
              wp_load.
              wp_pures.
              wp_load. 
              wp_pures.
              wp_store.
              iModIntro.
              iApply ("Hϕ" with "[HisPMap Hl'] ").
              simpl.
              unfold isPmap.
              simpl.
              unfold partial_alter.
              simpl.
              destruct (pmap.Pmap_ne_partial_alter f p0 ne) as [ | vne] eqn:E.
              2:{
                simpl.
                iExists ll0, l'.
                iFrame.
                done.
              } {
                assert (HnonEmpty: partial_alter f p0 (PNodes ne) ≠ PEmpty →
                           pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
                  {
                    intro H1.
                    unfold partial_alter in H1.
                    unfold Pmap_partial_alter in H1.
                    unfold pmap.Pmap_partial_alter_aux in H1. 
                    done.
                  }
                  assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p0 ne ≠ PEmpty).
                  {
                    apply HnonEmpty.
                    apply NoPEmpty.
                    done.
                  }
                  done.
              }
            + done.
          - destruct Hpos.
            assert (HfpkbNeq: fp key ≠ fp base). apply fp_inj; done.
            done.  
        }
      + (* The Proof of the Node 111. *)
        Print isPmap_ne.
        iIntros (ϕ) "[(%ll & %lr & %l' & %Hll'eq & Hl' & Hne1 & Hne2) [%Hf1 %Hf2]] Hϕ".
        fold isPmap_ne.
        rewrite Hll'eq.
        wp_rec.
        wp_pures.
        destruct (bool_decide_reflect (key = base)) as [HkebEq | HkebNeq].
        {
          wp_pures.
          wp_load.
          unfold get_left.
          unfold get_right.
          unfold get_mid.
          wp_pures.
          wp_load.
          wp_pures. 
          wp_apply (Hfv_constraint (SOMEV v0)).
          done.
          iIntros (rv0) "%H1".
          wp_load.
          wp_pures.
          wp_store.
          iModIntro.
          iApply "Hϕ".
          unfold isPmap.
          unfold partial_alter.
          rewrite HkebEq in Hf2.
          rewrite Hf2 in HfpBase.
          rewrite HfpBase.
          simpl.
          assert(HfNoneN: f (Some v0) ≠ None).
          done.
          assert(HfSome: ∃ vv, f (Some v0) = Some vv).
          {
            apply not_eq_None_Some.
            done.
          }
          destruct HfSome as [vv  Hvv].
          rewrite Hvv.
          simpl.
          iExists ll, lr, l'.
          iFrame.
          iSplit.
          done.
          assert (Hrv0fNone: Some rv0 = f (Some v0)).
          {
            apply H1.
          }
          rewrite Hvv in Hrv0fNone.
          assert(Hrv0vv: rv0 = vv).
          injection Hrv0fNone.
          intro Hrv0vveq.
          done.
          rewrite Hrv0vv.
          done.
        }
        { 
          wp_pures.
          destruct key' as [p1 | p0 |].
          - destruct Hf1 as [Hfp0 fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v00) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hlv2Eq: v2 = rv).
              {
                apply Hv2r.
                done.
              }
              rewrite Hlv2Eq.
              destruct (bool_decide_reflect (rv = lv)) as [HllEq | HllNeq].
              {
                done.
              }
              {
                wp_pures.
                wp_load.
                unfold get_right.
                wp_pures.          
                wp_apply ("IH" with "[Hne2]").
                - iSplit.
                  + iAssert (isPmap lr (PNodes ne2)) with "[Hne2]" as "H".
                    done.
                    iApply "H".
                  + iSplit.
                    done.
                    iPureIntro.
                    destruct p1 as [p1 | p0 |].
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _].
                    done.
                    destruct Hpos as [H1 _ ].
                    done.
                - iIntros (lr0) "HisPmap".
                  wp_pures.
                  unfold get_mid.
                  unfold get_right.
                  unfold get_left.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  unfold get_left.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  simpl.
                  unfold partial_alter.
                  simpl.      
                  destruct (pmap.Pmap_ne_partial_alter f p1 ne2) eqn:E.
                  2:{
                    simpl.
                    iExists ll, lr0, l'.
                    iSplit.
                    done.
                    iSplitL "Hl'".
                    done.
                    iFrame.
                  }
                  {
                    Check NoPEmpty.
                    assert (HnonEmpty:
                             partial_alter f p1 (PNodes ne2) ≠ PEmpty →
                             pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
                    {
                      intro H1.
                      unfold partial_alter in H1.
                      unfold Pmap_partial_alter in H1.
                      unfold pmap.Pmap_partial_alter_aux in H1. 
                      done.
                    }
                    assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p1 ne2 ≠ PEmpty).
                    {
                      apply HnonEmpty.
                      apply NoPEmpty.
                      done.
                    }
                    done.
                  }
              }
          - destruct Hf1 as [HlvEq fc_exec].
            wp_apply fc_exec.
            + done.
            + iIntros (v00) "(%v1 & %v2 & %Hv0 & %Hv2r & %Hv2l & %Hpos)".
              rewrite Hv0.
              wp_pures.
              assert (Hv2lv: v2 = lv). apply Hv2l; done.
              rewrite Hv2lv. 
              destruct (bool_decide_reflect (lv = lv)) as [HrlvEq | HrlvNEq].
              {
                wp_pures.
                wp_load.
                unfold get_left.
                wp_pures.
                wp_apply ("IH" with "[Hne1]").
                iSplit.
                iAssert (isPmap ll (PNodes ne1)) with "[Hne1]" as "H".
                done.
                iApply "H".
                iSplit.
                done.
                iPureIntro.
                destruct p0 as [p1 | p0 |].
                destruct Hpos as [Hp1 _].
                done.
                destruct Hpos as [Hp0 _].
                done.
                destruct Hpos.
                done.
                {
                  iIntros (ll0) "HisPmap".
                  wp_pures.
                  unfold get_right.
                  unfold get_mid.
                  wp_load.
                  wp_pures.
                  wp_load.
                  wp_pures.
                  wp_store.
                  iModIntro.
                  iApply "Hϕ".
                  simpl.
                  unfold partial_alter.
                  simpl.      
                  destruct (pmap.Pmap_ne_partial_alter f p0 ne1) eqn:E.
                  2:{
                    simpl.
                    iExists ll0, lr, l'.
                    iSplit.
                    done.
                    iSplitL "Hl'".
                    done.
                    iFrame.
                  }
                  {
                    Check NoPEmpty.
                    assert (HnonEmpty:
                             partial_alter f p0 (PNodes ne1) ≠ PEmpty →
                             pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
                    {
                      intro H1.
                      unfold partial_alter in H1.
                      unfold Pmap_partial_alter in H1.
                      unfold pmap.Pmap_partial_alter_aux in H1. 
                      done.
                    }
                    assert (HnonEmpty': pmap.Pmap_ne_partial_alter f p0 ne1 ≠ PEmpty).
                    {
                      apply HnonEmpty.
                      apply NoPEmpty.
                      done.
                    }
                    done.
                  }
                }
              }
              {
                done.
              } 
          - (* This case is impossible, as we already have key ≠ base. *)
            assert (HfpkebaseNeq: fp key ≠ fp base).
            {
              apply fp_inj.
              done.
            }
            assert (HfpkebaseEq: fp key = fp base).
            rewrite <- Hf2 in HfpBase.
            done.
            done.
        }
Qed.

End map_heaplang.
